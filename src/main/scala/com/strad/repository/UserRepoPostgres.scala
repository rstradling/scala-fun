package com.strad.repository

import com.strad.repository.Models.User
import cats.*
import cats.data.*
import cats.effect.*
import cats.implicits.*
import doobie.*
import doobie.implicits.*

class UserRepoPostgres[F[_]](transactor: Transactor[F])(using e: Async[F]) extends UserRepo[F]:
  def insertUserQuery(user: User): Update0 =
    sql"""insert into users ("firstName", "lastName", "email", "phone", "address")
      values (${user.firstName}, ${user.lastName}, 
      ${user.email}, ${user.phone}, ${user.address});"""
      .update
  def insertUser(user: User): F[User] =
    insertUserQuery(user)
      .withUniqueGeneratedKeys[Long]("userId")
      .transact(transactor)
      .map(id => user.copy(userId = id))

  def deleteUserByIdQuery(userId: Long): Update0 =
    sql"""DELETE from users where "userId"=${userId};""".update

  def deleteUserById(userId: Long): F[Unit] =
    deleteUserByIdQuery(userId)
    .withUniqueGeneratedKeys[Option[Long]]("userId")
    .transact(transactor)
    .void

  def getByUserIdQuery(userId: Long) =
    sql"""SELECT "userId", "firstName", "lastName", "email", "phone", "address"
          FROM users 
          WHERE "userId"=${userId}"""
          .query[User]

  def getUserById(userId: Long): F[Option[User]] =
        getByUserIdQuery(userId)
          .option
          .transact(transactor)

object UserRepoPostgres:
  def createTable[F[_]](transactor: Transactor[F])(using e: Async[F]) : F[Unit] =
    val create = sql"""
    CREATE TABLE users (
    "userId" BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "firstName" VARCHAR(128) NOT NULL,
    "lastName" VARCHAR(128) NOT NULL,
    "email" VARCHAR(128) NULL,
    "phone" VARCHAR(128) NULL,
    "address" VARCHAR NULL);
    """.update.run
    val drop =
      sql"""
            DROP TABLE IF EXISTS users
           """.update.run
    (drop, create).mapN(_ + _).transact(transactor).void


